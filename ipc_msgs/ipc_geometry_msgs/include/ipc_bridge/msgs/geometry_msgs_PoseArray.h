/* automatically generated by xdrgen from xdr/geometry_msgs_PoseArray.xdr
 * xdrgen cvs version: $Revision: 1.7 $ $Date: 2009/01/12 15:54:59 $
 * xdr/geometry_msgs_PoseArray.xdr last modified: Wed Apr 28 10:56:47 2010
 */

#ifndef INCgeometry_msgs_PoseArray_h
#define INCgeometry_msgs_PoseArray_h



#include <ipc_bridge/msgs/roslib_Header.h>
#include <ipc_bridge/msgs/geometry_msgs_Pose.h>


struct geometry_msgs_PoseArray {
  roslib_Header header;
  unsigned int poses_length;
  geometry_msgs_Pose *poses;
#define geometry_msgs_PoseArray_IPC_FORMAT "{" roslib_Header_IPC_FORMAT ",uint,<" geometry_msgs_Pose_IPC_FORMAT ":2>}"
  static const char *getIPCFormat(void) {
    return geometry_msgs_PoseArray_IPC_FORMAT;
  }


  geometry_msgs_PoseArray() : poses_length(0), poses(0) {}
  geometry_msgs_PoseArray(const geometry_msgs_PoseArray& msg) :
    header(msg.header), poses_length(msg.poses_length)
  {
    if (poses != 0)
      delete[] poses;
  
    poses = 0;
    if (msg.poses_length > 0)
      {
        poses = new geometry_msgs_Pose[poses_length];
        memcpy((void*)poses, (void*)msg.poses,
               poses_length*sizeof(geometry_msgs_Pose));
      }
  }
  ~geometry_msgs_PoseArray()
  {
    if (poses != 0)
      delete[] poses;
  }
  geometry_msgs_PoseArray& operator= (const geometry_msgs_PoseArray& msg)
  {
    header = msg.header;
    poses_length = msg.poses_length;
    
    if (poses != 0)
      delete[] poses;
  
    poses = 0;
    if (msg.poses_length > 0)
      {
        poses = new geometry_msgs_Pose[poses_length];
        memcpy((void*)poses, (void*)msg.poses,
               poses_length*sizeof(geometry_msgs_Pose));
      }

    return *this;
  }

};


namespace ipc_bridge
{
    namespace geometry_msgs
    {
        typedef geometry_msgs_PoseArray PoseArray;
    }
}


#endif /* INCgeometry_msgs_PoseArray_h */
