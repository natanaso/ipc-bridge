/* automatically generated by xdrgen from xdr/sensor_msgs_LaserScan.xdr
 * xdrgen cvs version: $Revision: 1.7 $ $Date: 2009/01/12 15:54:59 $
 * xdr/sensor_msgs_LaserScan.xdr last modified: Wed Apr 28 10:56:47 2010
 */

#ifndef INCsensor_msgs_LaserScan_h
#define INCsensor_msgs_LaserScan_h



#include <ipc_bridge/msgs/roslib_Header.h>


struct sensor_msgs_LaserScan {
  roslib_Header header;
  float angle_min;
  float angle_max;
  float angle_increment;
  float time_increment;
  float scan_time;
  float range_min;
  float range_max;
  unsigned int ranges_length;
  float *ranges;
  unsigned int intensities_length;
  float *intensities;
#define sensor_msgs_LaserScan_IPC_FORMAT "{" roslib_Header_IPC_FORMAT ",float,float,float,float,float,float,float,uint,<float:9>,uint,<float:11>}"
  static const char *getIPCFormat(void) {
    return sensor_msgs_LaserScan_IPC_FORMAT;
  }


  sensor_msgs_LaserScan() :
    angle_min(0), angle_max(0),
    angle_increment(0), scan_time(0),
    range_min(0), range_max(0),
    ranges_length(0), ranges(0),
    intensities_length(0), intensities(0) {}
  sensor_msgs_LaserScan(const sensor_msgs_LaserScan &msg) :
    header(msg.header),
    angle_min(msg.angle_min), angle_max(msg.angle_max),
    angle_increment(msg.angle_increment),
    scan_time(msg.scan_time),
    range_min(msg.range_min), range_max(msg.range_max),
    ranges_length(msg.ranges_length),
    intensities_length(msg.intensities_length)
  {
    if (ranges != 0)
      delete[] ranges;

    ranges = 0;
    if (msg.ranges_length > 0)
      {
        ranges = new float[ranges_length];
        memcpy((void*)ranges, (void*)msg.ranges, 
               ranges_length*sizeof(float));
      }

    if (intensities != 0)
      delete[] intensities;

    intensities = 0;
    if (intensities_length > 0)
      {
        intensities = new float[intensities_length];
        memcpy((void*)intensities, (void*)msg.intensities, 
               intensities_length*sizeof(float));
      }
  }
  ~sensor_msgs_LaserScan()
  {
    if (ranges != 0)
      delete[] ranges;
    ranges = 0;

    if (intensities != 0)
      delete[] intensities;
    intensities = 0;
  }
  sensor_msgs_LaserScan& operator= (const sensor_msgs_LaserScan& msg)
  {
    header = msg.header;
    angle_min = msg.angle_min;
    angle_max = msg.angle_max;
    angle_increment = msg.angle_increment;
    scan_time = msg.scan_time;
    range_min = msg.range_min;
    range_max = msg.range_max;
    ranges_length = msg.ranges_length;
    intensities_length = msg.intensities_length;

    if (ranges != 0)
      delete[] ranges;

    ranges = 0;
    if (msg.ranges_length > 0)
      {
        ranges = new float[ranges_length];
        memcpy((void*)ranges, (void*)msg.ranges, 
               ranges_length*sizeof(float));
      }

    if (intensities != 0)
      delete[] intensities;

    intensities = 0;
    if (intensities_length > 0)
      {
        intensities = new float[intensities_length];
        memcpy((void*)intensities, (void*)msg.intensities, 
               intensities_length*sizeof(float));
      }

    return *this;
  } 

};


namespace ipc_bridge
{
    namespace sensor_msgs
    {
        typedef sensor_msgs_LaserScan LaserScan;
    }
}


#endif /* INCsensor_msgs_LaserScan_h */
