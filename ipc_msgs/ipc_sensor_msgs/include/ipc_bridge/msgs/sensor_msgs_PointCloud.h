/* automatically generated by xdrgen from xdr/sensor_msgs_PointCloud.xdr
 * xdrgen cvs version: $Revision: 1.7 $ $Date: 2009/01/12 15:54:59 $
 * xdr/sensor_msgs_PointCloud.xdr last modified: Wed Apr 28 10:56:47 2010
 */

#ifndef INCsensor_msgs_PointCloud_h
#define INCsensor_msgs_PointCloud_h



#include <ipc_bridge/msgs/roslib_Header.h>
#include <ipc_bridge/msgs/geometry_msgs_Point32.h>
#include <ipc_bridge/msgs/sensor_msgs_ChannelFloat32.h>


struct sensor_msgs_PointCloud {
  roslib_Header header;
  unsigned int points_length;
  geometry_msgs_Point32 *points;
  unsigned int channels_length;
  sensor_msgs_ChannelFloat32 *channels;
#define sensor_msgs_PointCloud_IPC_FORMAT "{" roslib_Header_IPC_FORMAT ",uint,<" geometry_msgs_Point32_IPC_FORMAT ":2>,uint,<" sensor_msgs_ChannelFloat32_IPC_FORMAT ":4>}"
  static const char *getIPCFormat(void) {
    return sensor_msgs_PointCloud_IPC_FORMAT;
  }


  sensor_msgs_PointCloud() :
    points_length(0), points(0), channels_length(0), channels(0) {}
  sensor_msgs_PointCloud(const sensor_msgs_PointCloud &msg) :
    header(msg.header),
    points_length(msg.points_length), 
    channels_length(msg.channels_length)
  {
    if (points != 0)
      delete[] points;

    points = 0;
    if (msg.points_length > 0)
      {
        points = new geometry_msgs_Point32[msg.points_length];
        memcpy((void*)points, (void*)msg.points, 
               msg.points_length*sizeof(geometry_msgs_Point32));
      }

    if (channels != 0)
      delete[] channels;

    channels = 0;
    if (msg.channels_length > 0)
      {
        channels = new sensor_msgs_ChannelFloat32[msg.channels_length];
        memcpy((void*)channels, (void*)msg.channels, 
               msg.channels_length*sizeof(sensor_msgs_ChannelFloat32));
      }
  }
  ~sensor_msgs_PointCloud()
  {
    if (points != 0)
      delete[] points;
    points = 0;

    if (channels != 0)
      delete[] channels;
    channels = 0;
  }
  sensor_msgs_PointCloud& operator= (const sensor_msgs_PointCloud& msg)
  {
    header = msg.header;
    points_length = msg.points_length;
    channels_length = msg.channels_length;

    if (points != 0)
      delete[] points;

    points = 0;
    if (msg.points_length > 0)
      {
        points = new geometry_msgs_Point32[msg.points_length];
        memcpy((void*)points, (void*)msg.points, 
               msg.points_length*sizeof(geometry_msgs_Point32));
      }

    if (channels != 0)
      delete[] channels;

    channels = 0;
    if (msg.channels_length > 0)
      {
        channels = new sensor_msgs_ChannelFloat32[msg.channels_length];
        memcpy((void*)channels, (void*)msg.channels, 
               msg.channels_length*sizeof(sensor_msgs_ChannelFloat32));
      }

    return *this;
  } 

};


namespace ipc_bridge
{
    namespace sensor_msgs
    {
        typedef sensor_msgs_PointCloud PointCloud;
    }
}


#endif /* INCsensor_msgs_PointCloud_h */
